"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapCrossDatasetReferences = void 0;
const graphql_1 = require("graphql");
const CDR_DIRECTIVE = 'crossDatasetReference';
// Function to extract array of string value from a ValueNode
const getStringArrayArgumentValuesFromDirective = (directive, argument) => {
    const values = [];
    for (const arg of directive.arguments || []) {
        if (arg.name.value === argument) {
            if (arg.value.kind === graphql_1.Kind.LIST) {
                arg.value.values.forEach((value) => {
                    if (value.kind === graphql_1.Kind.STRING) {
                        values.push(value.value);
                    }
                });
            }
        }
    }
    return values;
};
const referenceDirectiveNode = {
    kind: graphql_1.Kind.DIRECTIVE,
    name: {
        kind: graphql_1.Kind.NAME,
        value: 'reference',
    },
};
const typeNameForMapping = (typeNames) => {
    return typeNames.join('Or');
};
// This function rewrites the Schema to treat crossDatasetReference fields as
// references, since we will assume the required schemas and content is added as
// additional source plugin configurations.
function mapCrossDatasetReferences(api) {
    const astNode = (0, graphql_1.parse)(api);
    // First pass: Find any named types that have cdr directives on them
    const cdrMapping = {};
    (0, graphql_1.visit)(astNode, {
        enter(node) { },
        [graphql_1.Kind.OBJECT_TYPE_DEFINITION](node) {
            var _a;
            if (node.name.value) {
                const cdrDirective = (_a = node.directives) === null || _a === void 0 ? void 0 : _a.find((d) => d.name.value === CDR_DIRECTIVE);
                if (cdrDirective) {
                    // This is a type that has a cdr directive on it
                    //let typeName = getStringArgumentValueFromDirective(cdrDirective, 'typeName')
                    let typeNames = getStringArrayArgumentValuesFromDirective(cdrDirective, 'typeNames');
                    if (typeNames) {
                        cdrMapping[node.name.value] = typeNames;
                    }
                }
            }
        },
    });
    const unionDefinitions = [];
    // Find all the values in cdrMapping that have more than 1 value
    for (const key in cdrMapping) {
        if (cdrMapping[key].length > 1) {
            // Create a union type for this set of types
            unionDefinitions.push({
                kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: typeNameForMapping(cdrMapping[key]),
                },
                types: cdrMapping[key].map((key) => {
                    return {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: key,
                        },
                    };
                }),
            });
        }
    }
    // Add our new Union types
    const newAST = Object.assign(Object.assign({}, astNode), { definitions: [...astNode.definitions, ...unionDefinitions] });
    // Second pass: Rewrite the schema to replace CDR types with the appropriate
    // target type and add @reference directive where appropriate
    const modifiedTypes = (0, graphql_1.visit)(newAST, {
        [graphql_1.Kind.FIELD_DEFINITION](fieldNode) {
            var _a;
            const cdrDirective = (_a = fieldNode.directives) === null || _a === void 0 ? void 0 : _a.find((d) => d.name.value === CDR_DIRECTIVE);
            let mappedTypeNames = undefined;
            if (fieldNode.type.kind === graphql_1.Kind.NAMED_TYPE) {
                if (cdrDirective) {
                    // This is a field that has a cdr directive on it
                    // TODO: look up any configured typePrefixes for the dataset
                    mappedTypeNames = getStringArrayArgumentValuesFromDirective(cdrDirective, 'typeNames');
                }
                else {
                    // This is a field that does not have a cdr directive on it
                    // Check if the field type is a CDR type
                    const fieldName = fieldNode.type.name.value;
                    if (fieldName in cdrMapping) {
                        mappedTypeNames = cdrMapping[fieldName];
                    }
                }
            }
            if (fieldNode.type.kind === graphql_1.Kind.LIST_TYPE) {
                const innerType = fieldNode.type.type; // TypeScript type assertion
                const fieldName = innerType.name.value;
                // Check if the field type is a CDR type
                if (fieldName in cdrMapping) {
                    mappedTypeNames = cdrMapping[fieldName];
                }
            }
            if (mappedTypeNames) {
                // Replace the cdr directive with a reference directive and replace
                // the type name with the actual target type
                let directives = (fieldNode.directives || []).filter((d) => d.name.value !== CDR_DIRECTIVE);
                if (cdrDirective) {
                    // If there was a cdr directive, replace it with a reference directive
                    directives = [...directives, referenceDirectiveNode];
                }
                if (fieldNode.type.kind === graphql_1.Kind.NAMED_TYPE) {
                    return Object.assign(Object.assign({}, fieldNode), { directives, type: Object.assign(Object.assign({}, fieldNode.type), { name: Object.assign(Object.assign({}, fieldNode.type.name), { value: typeNameForMapping(mappedTypeNames) }) }) });
                }
                if (fieldNode.type.kind === graphql_1.Kind.LIST_TYPE) {
                    return Object.assign(Object.assign({}, fieldNode), { type: Object.assign(Object.assign({}, fieldNode.type), { type: {
                                kind: graphql_1.Kind.NAMED_TYPE,
                                name: {
                                    kind: graphql_1.Kind.NAME,
                                    value: typeNameForMapping(mappedTypeNames),
                                },
                            } }) });
                }
            }
            return fieldNode;
        },
        [graphql_1.Kind.UNION_TYPE_DEFINITION](node) {
            var _a;
            // Check if any of the union types match keys in the cdrMapping
            const modifiedTypes = (_a = node.types) === null || _a === void 0 ? void 0 : _a.map((typeNode) => {
                const typeName = typeNode.name.value;
                if (cdrMapping[typeName]) {
                    return Object.assign(Object.assign({}, typeNode), { name: {
                            kind: graphql_1.Kind.NAME,
                            value: cdrMapping[typeName],
                        } });
                }
                return typeNode; // return the type unchanged if it's not in the cdrMapping
            });
            // Return the modified union node
            return Object.assign(Object.assign({}, node), { types: modifiedTypes });
        },
    });
    return (0, graphql_1.print)(modifiedTypes);
}
exports.mapCrossDatasetReferences = mapCrossDatasetReferences;
//# sourceMappingURL=mapCrossDatasetReferences.js.map